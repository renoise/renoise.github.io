<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=UTF-8" http-equiv="content-type" />
<title>! Introduction.txt</title>
<style type="text/css">
body {
    font-family: Arial, Helvetica, sans-serif;
    margin: 1em;
    background: #ffffff;
    color: #000000;
}

a:link, a:active {
    color: #14cc43;
}

a:visited {
    color: green;
}

a:hover {
    color: #ff00fd;
    background: #000000;
}

h1, h2, h4 {
    background: #eeeeee;
    padding: 10px;
    background-color: #eeeeee;
    border: 4px solid #ccc;
    border-radius: 10px;
    -moz-border-radius: 10px;
    -webkit-border-radius: 10px;
}

.lua {
    font-weight: bold;
    font-size: 105%;
    border: 1px dashed #999;
    padding: 1em;
    background: #fff7c1;
}

code {
    background: #fff7c1;
}

pre {
    margin-bottom: 2.25em;
}

blockquote {
    background: #f9f9f9;
    border-left: 10px solid #ccc;
    margin: 1px;
    padding: 0.5em 10px;
}

blockquote:before {
    color: #ccc;
    font-size: 4em;
    line-height: 0.1em;
    margin-right: 0.25em;
    vertical-align: -0.4em;
}

blockquote p {
    display: inline;
    font-size: small;
}

ul {
    margin-left: 0;
    padding-left: 1em;
}
</style>
</head>
<body>
<h4>Contents</h4>

<ul>
<li><a href="#h1_1">Renoise Scripting Reference and HOWTOs - Introduction</a><br />

<ul>
<li><a href="#h2_2">Scripting Development Tools in Renoise</a>  </li>
<li><a href="#h2_3">What can be scripted, what can't? What's this scripting all about?</a>  </li>
<li><a href="#h2_4">Renoise Lua API Overview</a>  </li>
<li><a href="#h2_5">Creating Renoise Tools</a>  </li>
<li><a href="#h2_6">MIDI Controller Scripting with Duplex</a>  </li>
<li><a href="#h2_7">Debugging Renoise Scripts</a>  </li>
</ul></li>
</ul>

<h1 id="h1_1">Renoise Scripting Reference and HOWTOs - Introduction</h1>

<p>Welcome to the Renoise scripting Guide. In all the various "Documention" files,
we will give you an overview on how to write tools for Renoise; how to debug 
them, what's possible to "script", what's not, and much more. Please read this
introduction carefully to get an idea on how to get started, and to avoid common
pitfalls and FAQs.</p>

<h2 id="h2_2">Scripting Development Tools in Renoise</h2>

<p>By default Renoise has all scripting utilities hidden; to keep things as easy as
possible for those who don't want to mess around with code. If you want to write
scripts, then the first thing you have to do is enable the hidden development
tools that are built into Renoise. This can be done by:</p>

<ul>
<li><p>Launching the Renoise executable with the argument "--scripting-dev"</p></li>
<li><p>Opening Renoise's config.xml file from the preferences folder, and setting the
<ShowScriptingDevelopmentTools> property to "true". This way, you don't have
to pass the above mentioned argument every time you launch Renoise.</p></li>
</ul>

<p>Enabling scripting will add a new main menu entry "Tools" (or add new
entries there if it already exists).</p>

<p>In the "Tools" menu you will find:</p>

<ul>
<li><p><strong>Reload All Tools:</strong> This will force a reload of all installed and running
scripting tools. This can be handy when adding new tools by hand or when
changing them.</p></li>
<li><p><strong>Scripting Console &amp; Editor:</strong> This is the main developing scripting tool.
It allows you to:</p>

<ul>
<li>Evaluate scripts or commands in realtime with a terminal (command-line)</li>
<li>Watch any script's output (all "print"s and errors will be redirected here)</li>
<li>Create, view and edit Lua, text, and XML files that will make up tools
for Renoise. More about this later...</li>
</ul></li>
<li><p>Show <strong>Example Tools</strong> that target script developers.</p></li>
</ul>

<h2 id="h2_3">What can be scripted, what can't? What's this scripting all about?</h2>

<p>Right now (in this Renoise release), you can make use of scripts in the
following places:</p>

<ul>
<li><p>Run scripts and commands via a terminal in realtime using the
"Scripting Console &amp; Editor".</p></li>
<li><p>Create tools: Add new and custom functionality to Renoise. Tools are small
file bundles with Lua script(s) and a description file (manifest.xml) that
make use of the Renoise API. Tools can be distributed and installed via
drag and drop (by bundling them and hiding the code). This way, not only
developers can use scripts, but also users who don't want to mess around with
technical details. We'll describe these types bundles later on...</p>

<p>Some examples of what you can do with Renoise Tools:</p>

<ul>
<li><p>New context menu entries and keyboard shortcuts. Think "My Improved Pattern
Jump", "My Bypass all DSP Devices in Track", "My Generate Chip Sound
Sample" commands, and so on.</p></li>
<li><p>Custom graphical user interface elements with the look and feel of Renoise
itself. Perfectly integrate your tools into Renoise, and make them easy to
use for other users.</p></li>
<li><p>Manipulate Renoise's main window or song (patterns, tracks, instruments, 
anything that makes up a song). Generate, filter, or process song data in 
any way you can think of. E.g. for algorithmic composition, instrument 
creation, automation, etc. The sky is the limit.</p></li>
<li><p>Nibbles ;)</p></li>
</ul></li>
<li><p>MIDI controller scripting: Create bidirectional MIDI or OSC implementations
for any controller hardware:</p>

<p>For example, make your Launchpad or Monome behave exactly how you want them 
to, and share your settings with others. Tools like these can be a simple auto
mapping of your MIDI controller, like plug &amp; play support for Mackie Control,
Behringer MIDI Mixers, and so on.</p>

<p>To make this easier, Renoise offers a tool called "Duplex" which already has
support for several MIDI/OSC controllers. Duplex is a very flexible,
object-oriented approach to handling MIDI controllers in Renoise, and also
offers virtual UIs for the MIDI controllers that are supported by Duplex.
This way you can virtually test and use such controllers in Renoise without
even owning them. ;)</p>

<p>NB: You don't have to use Duplex to write MIDI/OSC controller scripts in
Renoise, but it is a nice (and supported) framework that makes this type of
development easier.</p></li>
<li><p>Create, configure, or override Renoise's default MIDI/OSC bindings:
Renoise has a default set of MIDI mappings that can be assigned manually by
the user. These can be inherited, extended and tweaked to fit your needs.
Renoise also has a default OSC implementation which can tweaked and overriden
to do "your stuff."</p></li>
</ul>

<p>What's <em>NOT</em> possible with Renoise tools:</p>

<ul>
<li><p>Change Renoise's existing behaviour. Like, you can't make all C-4s in the
pattern editor yellow instead of white. You can write your own pattern
editor, but not change the existing one.</p></li>
<li><p>Realtime access. Except for OSC and MIDI IO, you can't write scripts that
run in the audio player. In other words, you can not script new realtime
DSPs - yet. But you can, for example, write a tool that creates samples or
manipulates existing samples. This limitation might change in the future.
For now you can make a VST, AudioUnit, or LADSPA/DSSI plug-in.</p></li>
</ul>

<h2 id="h2_4">Renoise Lua API Overview</h2>

<p>The XXX.API files in this documentation folder will list all available Lua
functions and classes that can be accessed from scripts in Renoise.
If you are familiar with Renoise, the names of the classes, functions and
properties should be self explanitory.</p>

<p>Here is a small overview of what the API exposes:</p>

<p><strong>Renoise.API</strong><br />
Renoise API version number and some global accessors like "song", "app" are here.</p>

<p><strong>Renoise.Application.API</strong><br />
Access to the main Renoise application and window, main user interface.</p>

<p><strong>Renoise.Song.API</strong><br />
Access to the song and all its components (instruments, samples, tracks...)</p>

<p><strong>Renoise.Document.API</strong><br />
Generic "observer pattern" document creation and access, used by the
song/app and to create persistent data (preferences, presets).</p>

<p><strong>Renoise.ScriptingTool.API</strong><br />
Available to XRNX tools only: Interact with Renoise; create menus, keybindings.</p>

<p><strong>Renoise.Socket.API</strong><br />
Inter-process and network communication functions and classes.</p>

<p><strong>Renoise.OSC.API</strong><br />
Tools to generate and receive OSC messages, bundles over the network.</p>

<p><strong>Renoise.Midi.API</strong><br />
"Raw" MIDI device interaction (send, receive MIDI messages from any devices.)</p>

<p>A note about the general API design:</p>

<ul>
<li><p>Whatever you do with the API, you should never be able to fatally crash
Renoise. If you manage to do this, then please file a bug report in our forums
so we can fix it. All errors, as stupid they might be, should always result in
a clean error message from Lua.</p></li>
<li><p>The Renoise Lua API also allows global File IO and external program execution
(via os.execute()) which can obviously be hazardous. Please be careful with
these, as you would with programming in general...</p></li>
</ul>

<p>Some notes about the documentation, and a couple of tips:</p>

<ul>
<li><p>All classes, functions in the API, are nested in the namespace (Lua table)
"renoise". E.g: to get the application object, you will have to type
"renoise.app()"</p></li>
<li><p>The API is object-oriented, and thus split into classes. The references
will first note the class name (e.g. 'renoise.Application'), then list its
Constants, Properties, Functions and Operators.
All properties and functions are always listed with their full path to make
it clear where they belong and how to access them.</p></li>
<li><p>Return values (or arguments / types of properties) are listed in brackets.
"-> [string]" means that a string is returned. When no brackets are listed,
the function will not return anything.</p></li>
<li><p>Nearly all functions are actually "methods", so you have to invoke them
via the colon operator ":" E.g. 'renoise.app():show_status("Status Message")'
If you're new to Lua, this takes a while to get used to. Don't worry, it'll
make sense sooner or later. ;)</p></li>
<li><p>Properties are syntactic sugar for get/set functions. "song().comments"
will invoke a function which returns "comments". But not all properties
have setters, and thus can only be used as read-only "getters". Those are
marked as "[read-only, type]".
Again mind the colon; which you don't need when accessing properties!</p></li>
<li><p>All exposed "objects" are read-only (you can not add new fields, properties).
In contrast, the "classes" are not. This means you can extend the API classes 
with your own helper functions, if needed, but can not add new properties to 
objects. Objects, like for example the result of "song()", are read-only to 
make it easier to catch typos. <code>song().transport.bmp = 80</code> will fire an error,
because there is no such property 'bmp.' You probably meant
<code>song().transport.bpm = 80</code> here. If you need to store data somewhere,
do it in your own tables, objects instead of using the Renoise API objects.</p></li>
<li><p>"some_property, _observable" means, that there is also an observer object
available for the property. An observable object allows you to attach
notifiers (global functions or methods) that will be called as soon as a
value has changed. Please see Renoise.Document.API for more info about
observables and related classes.</p>

<p>A small example using bpm:</p>

<pre class="lua" style="font-family:monospace;">renoise.song<span style="color: #66cc66;">&#40;</span><span style="color: #66cc66;">&#41;</span>.transport.bpm_observable:add_notifier<span style="color: #66cc66;">&#40;</span><span style="color: #b1b100;">function</span><span style="color: #66cc66;">&#40;</span><span style="color: #66cc66;">&#41;</span>
  <span style="color: #b1b100;">print</span><span style="color: #66cc66;">&#40;</span><span style="color: #ff0000;">&quot;bpm changed&quot;</span><span style="color: #66cc66;">&#41;</span>
<span style="color: #b1b100;">end</span><span style="color: #66cc66;">&#41;</span>
&nbsp;
<span style="color: #808080; font-style: italic;">-- will print &quot;bpm changed&quot;, but only if the bpm was not 120 before</span>
renoise.song<span style="color: #66cc66;">&#40;</span><span style="color: #66cc66;">&#41;</span>.transport.bpm <span style="color: #66cc66;">=</span> <span style="color: #cc66cc;">120</span></pre>

<p>The above notifier is called when anything changes the bpm, including your
script, other scripts, or anything else in Renoise (you've automated the
BPM in the song, entered a new BPM value in Renoise's GUI, whatever...)</p>

<p>Lists like "renoise.song().tracks[]" can also have notifiers. But these
will only fire when the list layout has changed: an element was added,
removed or elements in the list changed their order. They will not fire when
the list values changed. Attach notifiers to the list elements to get such
notifications.</p></li>
<li><p>Can't remember what the name of function XYZ was? In the scripting terminal
you can list all methods/properties of API objects (or your own class objects)
via the global function <code>oprint(some_object)</code> - e.g. <code>oprint(renoise.song())</code>.
To dump the renoise module/class layout, use <code>rprint(renoise)</code>.</p></li>
</ul>

<h2 id="h2_5">Creating Renoise Tools</h2>

<ul>
<li><p>Developing XRNX tools:
As previously mentioned, Renoise tools are file bundles with an XRNX
extension. Tools have the following layout:</p>

<ul>
<li>/some.bundle.id.xrnx/</li>
<li>manifest.xml -> XML file with information about the tool (author, id...)</li>
<li>main.lua -> entry point: loaded by Renoise to execute the tool</li>
</ul>

<p>You can import other Lua files into "main.lua" via Lua's "require" function
if appropriate, and also include resource files (icons, bitmaps, text files,
or executables) into your bundles as needed.</p>

<p>For a detailed description of the bundle layout and the main.lua,
manifest.lua specifications, have a look at the "com.renoise.Example.xrnx"
tool please.</p></li>
<li><p>Distributing XRNX tools:
To share your tools with others, you can create Zip files out of your
bundles, which can then simply be dragged and dropped into Renoise by the
user.
To do so, zip all the bundle's content (the !content!, not the bundle folder
itself), and rename this Zip file to "SomeName.xrnx". Renoise will accept such
XRNX zips as drag and drop targets, copy, install and activate the tool
automatically.</p></li>
</ul>

<h2 id="h2_6">MIDI Controller Scripting with Duplex</h2>

<p>If you want to add support for your MIDI controller into Duplex, or help extend
the Duplex framework, have a look at the Duplex XRNX tool.</p>

<p>In the XRNX bundle you'll find some information about the Duplex API and
how to create new controller mappings.</p>

<p>The Duplex code can also be viewed online in the XRNX repository at:
<a href="http://code.google.com/p/xrnx/source/browse/trunk/Tools#Tools/com.renoise.Duplex.xrnx">http://code.google.com/p/xrnx/source/browse/trunk/Tools#Tools/com.renoise.Duplex.xrnx</a></p>

<p>More information can be found in Duplex manual, available here:
<a href="http://oscillity.net/renoise/duplex/Duplex_manual.pdf">http://oscillity.net/renoise/duplex/Duplex_manual.pdf</a></p>

<h2 id="h2_7">Debugging Renoise Scripts</h2>

<p>If tracing/debugging in the console with print, oprint and rprint isn't enough,
you can try attaching a command-line based debugger to your scripts. Have a look
at the Debugging document for more information and a small tutorial.</p>

<p>Enjoy extending, customizing and automating Renoise ;)</p>
</body></html>